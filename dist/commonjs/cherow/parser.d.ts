import * as ESTree from './estree';
import { Options, Delegate } from './cherow';
import { Token } from './token';
import { Context, Flags, Clob, JSXElement } from './flags';
export interface Lookahead {
    index: number;
    column: number;
    line: number;
    startLine: number;
    lastLine: number;
    startColumn: number;
    lastColumn: number;
    token: Token;
    tokenValue: string;
    tokenRaw: any;
    startIndex: number;
    lastIndex: number;
    tokenRegExp: number;
    flags: Flags;
}
export interface Location {
    line: number;
    column: number;
    index: number;
}
export declare class Parser {
    private readonly source;
    private flags;
    private index;
    private line;
    private column;
    private startIndex;
    private startLine;
    private startColumn;
    private lastIndex;
    private lastLine;
    private lastColumn;
    private token;
    private tokenValue;
    private tokenRaw;
    private tokenRegExp;
    private lastChar;
    private sourceFile;
    private comments;
    private errors;
    private labelSet;
    private errorLocation;
    private delegate;
    constructor(source: string, sourceFile: string, delegate?: Delegate | null);
    parseProgram(context: Context, options?: Options | null): ESTree.Program;
    parseStatementList(context: Context): ESTree.Statement[];
    parseModuleItemList(context: Context): ESTree.Statement[];
    private hasNext();
    private advance();
    private consumeUnicode(ch);
    private nextChar();
    private storeRaw(start);
    private readNext(prev, message?);
    private nextUnicodeChar();
    private consumeOpt(code);
    private consumeLineFeed(state);
    private advanceNewline();
    private scan(context);
    private skipMultiLineComment(context, state);
    private skipSingleLineComment(context, state);
    private addComment(context, state, commentStart);
    private scanPrivateName(context, _ch);
    private scanIdentifier(context);
    private scanUnicodeCodePointEscape(context);
    private scanIdentifierUnicodeEscape();
    private scanNumericFragment(context, state);
    private scanDecimalDigitsOrFragment(context);
    private scanBinarOrOctalyDigits(context, base, opt, state);
    private scanHexDigits(context, state);
    private scanImplicitOctalDigits(context, state);
    private scanNumeric(context, state);
    private scanRegularExpression(context);
    private testRegExp(pattern, flags, _mask);
    private scanString(context, quote);
    private throwStringError(context, code);
    private scanEscapeSequence(context, first);
    private consumeTemplateBrace(context);
    private scanTemplate(context, first);
    private scanLooserTemplateSegment(ch);
    private lookahead();
    private rewindState(state);
    private getLocation();
    parseDirective(context: Context): any;
    private consumeSemicolon(context);
    private expect(context, t);
    private consume(context, t);
    private validateParams(context, params);
    private nextTokenIsLeftParenOrPeriod(context);
    private nextTokenIsIdentifierOrKeywordOrGreaterThan(context);
    private nextTokenIsFuncKeywordOnSameLine(context);
    private isLexical(context);
    private finishNode<_T>(context, pos, node);
    private report(type, ...value);
    private tolerate(context, type, ...value);
    private reportUnexpectedTokenOrKeyword(t?);
    private nextToken(context);
    parseExportDefault(context: Context, pos: Location): ESTree.ExportDefaultDeclaration;
    parseExportDeclaration(context: Context): ESTree.ExportAllDeclaration | ESTree.ExportNamedDeclaration | ESTree.ExportDefaultDeclaration;
    parseNamedExportDeclaration(context: Context): ESTree.ExportSpecifier;
    parseExportAllDeclaration(context: Context, pos: Location): ESTree.ExportAllDeclaration;
    parseModuleSpecifier(context: Context): ESTree.Literal;
    parseImportSpecifier(context: Context): ESTree.ImportSpecifier;
    parseNamedImport(context: Context, specifiers: ESTree.Specifiers[]): void;
    parseImportNamespaceSpecifier(context: Context, specifiers: ESTree.Specifiers[]): void;
    parseImportDefaultSpecifier(context: Context): ESTree.ImportDefaultSpecifier;
    parseImportDeclaration(context: Context): ESTree.ImportDeclaration;
    parseImportClause(context: Context): ESTree.Specifiers[];
    parseModuleItem(context: Context): any;
    parseStatementListItem(context: Context): any;
    parseStatement(context: Context): ESTree.Statement;
    parseExpressionOrLabelledStatement(context: Context): ESTree.ExpressionStatement | ESTree.LabeledStatement;
    parseIfStatementChild(context: Context): ESTree.Statement | ESTree.FunctionDeclaration;
    parseIfStatement(context: Context): any;
    parseWhileStatement(context: Context): ESTree.WhileStatement;
    parseWithStatement(context: Context): ESTree.WhileStatement;
    parseDoWhileStatement(context: Context): ESTree.DoWhileStatement;
    parseContinueStatement(context: Context): ESTree.ContinueStatement;
    parseBreakStatement(context: Context): ESTree.BreakStatement;
    parseThrowStatement(context: Context): ESTree.ThrowStatement;
    parseTryStatement(context: Context): ESTree.TryStatement;
    parseCatchBlock(context: Context): ESTree.CatchClause;
    parseSwitchStatement(context: Context): ESTree.SwitchStatement;
    parseCaseOrDefaultClause(context: Context): ESTree.SwitchCase;
    parseReturnStatement(context: Context): ESTree.ReturnStatement;
    parseDebuggerStatement(context: Context): ESTree.DebuggerStatement;
    parseEmptyStatement(context: Context): ESTree.EmptyStatement;
    parseBlockStatement(context: Context): ESTree.BlockStatement;
    parseVariableStatement(context: Context): ESTree.VariableDeclaration;
    parseVariableDeclarationList(context: Context): ESTree.VariableDeclarator[];
    parseVariableDeclaration(context: Context): ESTree.VariableDeclarator;
    parseExpressionStatement(context: Context): ESTree.ExpressionStatement;
    parseExpression(context: Context, pos: Location): ESTree.Expression;
    private isIdentifier(context, t);
    private reinterpret(context, node);
    parseYieldExpression(context: Context, pos: Location): ESTree.YieldExpression;
    parseAssignmentExpression(context: Context): ESTree.AssignmentExpression | ESTree.YieldExpression | ESTree.ArrowFunctionExpression;
    parseConditionalExpression(context: Context, pos: Location): any;
    parseBinaryExpression(context: Context, minPrec: number, pos: Location, expr?: ESTree.Expression): ESTree.Expression;
    parseAwaitExpression(context: Context, pos: Location): ESTree.AwaitExpression;
    parseUnaryExpression(context: Context): ESTree.UnaryExpression | ESTree.Expression;
    private isEvalOrArguments(value);
    parseUpdateExpression(context: Context, pos: Location): ESTree.Expression;
    parseSuperProperty(context: Context): ESTree.Expression;
    parseImportExpressions(context: Context, pos: Location): ESTree.Expression;
    parseMetaProperty(context: Context, meta: ESTree.Identifier, pos: Location): ESTree.MetaProperty;
    parseNewTargetExpression(context: Context, _t: Token, name: string, pos: Location): ESTree.MetaProperty;
    parseNewExpression(context: Context): any;
    parseLeftHandSideExpression(context: Context, pos: Location): ESTree.Expression;
    parseIdentifierNameOrPrivateName(context: Context): ESTree.PrivateName | ESTree.Identifier;
    parseMemberExpression(context: Context, pos: Location, expr?: ESTree.CallExpression | ESTree.Expression): ESTree.Expression;
    parseTemplateLiteral(context: Context): ESTree.TemplateLiteral;
    parseTemplateHead(context: Context, cooked: string | null | undefined, raw: string, pos: Location): ESTree.TemplateElement;
    parseTemplate(context: Context, expressions?: ESTree.Expression[], quasis?: ESTree.TemplateElement[]): ESTree.TemplateLiteral;
    parseTemplateSpans(context: Context, pos?: Location): ESTree.TemplateElement;
    parseCallExpression(context: Context, pos: Location, expr: ESTree.Expression): ESTree.Expression | ESTree.CallExpression;
    parseArgumentList(context: Context): ESTree.Expression[];
    parseSpreadElement(context: Context): ESTree.SpreadElement;
    parseAndClassifyIdentifier(context: Context): ESTree.Identifier | void;
    parsePrimaryExpression(context: Context, pos: Location): any;
    parseAsyncFunctionExpression(context: Context, pos: Location): ESTree.FunctionExpression | ESTree.FunctionDeclaration | ESTree.CallExpression | ESTree.ArrowFunctionExpression | ESTree.Identifier;
    parseObjectLiteral(context: Context): ESTree.ObjectExpression;
    parsePropertyDefinition(context: Context): ESTree.Property;
    parseMethodDeclaration(context: Context, state: Clob): ESTree.FunctionExpression;
    parseComputedPropertyName(context: Context): ESTree.AssignmentExpression | ESTree.ArrowFunctionExpression | ESTree.YieldExpression;
    parsePropertyName(context: Context, _state?: Clob): ESTree.Expression;
    parseArrayLiteral(context: Context): ESTree.ArrayExpression;
    parseClass(context: Context): ESTree.ClassExpression | ESTree.ClassDeclaration;
    parseClassElementList(context: Context, state: Clob): ESTree.ClassBody;
    parseClassElement(context: Context, state: Clob): ESTree.FieldDefinition | ESTree.MethodDefinition | void;
    parseFieldDefinition(context: Context, state: Clob, key: any, pos: Location): ESTree.FieldDefinition;
    parseFieldOrMethodDeclaration(context: Context, state: Clob, key: ESTree.Expression, pos: Location): ESTree.MethodDefinition;
    parsePrivateName(context: Context, pos: Location): ESTree.PrivateName;
    parseArrowFunctionExpression(context: Context, pos: Location, params: ESTree.Node[], formalArgs?: string[]): ESTree.ArrowFunctionExpression;
    parseRestElement(context: Context, params?: string[]): any;
    parseExpressionCoverGrammar(context: Context): ESTree.Node;
    parseRegularExpressionLiteral(context: Context): ESTree.RegExpLiteral;
    parseNullOrTrueOrFalseExpression(context: Context, pos: Location): ESTree.Literal;
    parseThisExpression(context: Context): ESTree.ThisExpression;
    parseBigIntLiteral(context: Context, pos: Location): ESTree.BigIntLiteral;
    parseLiteral(context: Context): ESTree.Literal;
    parseIdentifier(context: Context): ESTree.Identifier;
    parseBindingIdentifierOrBindingPattern(context: Context, params?: string[]): any;
    parseAssignmentRestElement(context: Context, params?: string[]): ESTree.RestElement;
    parseAssignmentPattern(context: Context, params: string[], pos?: Location, pattern?: any): ESTree.AssignmentPattern;
    parseArrayElementsBindingPattern(context: Context, params?: string[]): ESTree.ArrayPattern;
    parseRestProperty(context: Context, params: string[]): ESTree.RestElement;
    private ObjectAssignmentPattern(context, params);
    parseAssignmentProperty(context: Context, params?: string[]): ESTree.AssignmentProperty;
    parseBindingIdentifier(context: Context): ESTree.Identifier;
    parseIdentifierName(context: Context, t: Token): ESTree.Identifier;
    parseFunctionName(context: Context): ESTree.Identifier;
    parseFunctionDeclaration(context: Context): ESTree.FunctionDeclaration;
    parseFunctionExpression(context: Context, isAsync?: boolean, pos?: {
        line: number;
        column: number;
        index: number;
    }): ESTree.FunctionExpression;
    parseFunction(context: Context, id: ESTree.Identifier | null | undefined, pos: Location, state?: Clob): ESTree.FunctionExpression | ESTree.FunctionDeclaration;
    parseFunctionBody(context: Context, params?: any[]): ESTree.BlockStatement;
    parseFormalParameterList(context: Context, state: Clob): any;
    parseForStatement(context: Context): ESTree.ForStatement | ESTree.ForInStatement | ESTree.ForOfStatement;
    /** JSX */
    parseJSXChildren(context: Context): any;
    parseJSXChild(context: Context, _pos: Location): ESTree.JSXText | ESTree.JSXExpressionContainer | ESTree.JSXSpreadChild | ESTree.JSXElement | undefined;
    parseJSXSpreadChild(context: Context): ESTree.JSXSpreadChild;
    parseJSXText(context: Context): ESTree.JSXText;
    parseJSXEmptyExpression(context: Context, pos: Location): ESTree.JSXEmptyExpression;
    parseJSXExpressionContainer(context: Context): ESTree.JSXExpressionContainer | ESTree.JSXSpreadChild;
    parseJSXClosingElement(context: Context, state: JSXElement): any;
    private scanJSXString(context, quote);
    private scanJSXAttributeValue(context);
    parseJSXSpreadAttribute(context: Context): any;
    parseJSXAttributeName(context: Context): ESTree.JSXIdentifier | ESTree.JSXNamespacedName;
    parseJSXAttribute(context: Context): ESTree.JSXAttribute;
    parseJSXExpressionAttribute(context: Context): ESTree.JSXExpressionContainer | ESTree.JSXSpreadChild;
    parseJSXAttributes(context: Context): ESTree.JSXAttribute[];
    private scanJSX();
    private nextJSXToken();
    parseJSXIdentifier(context: Context): ESTree.JSXIdentifier;
    parseJSXNamespacedName(context: Context, namespace: ESTree.JSXIdentifier | ESTree.JSXMemberExpression, pos: Location): ESTree.JSXNamespacedName;
    parseJSXMemberExpression(context: Context, expr: ESTree.JSXIdentifier | ESTree.JSXMemberExpression, pos: Location): ESTree.JSXMemberExpression;
    parseJSXElementName(context: Context): ESTree.Node;
    parseJSXElementOrFragment(context: Context): ESTree.JSXElement;
    parseJSXOpeningFragment(context: Context, pos: Location): any;
    parseJSXOpeningElement(context: Context, state: JSXElement, pos: Location): any;
    parseJSXElement(context: Context, children: ESTree.JSXElement[] | undefined, openingElement: ESTree.JSXOpeningElement, closingElement: ESTree.JSXClosingElement | null, pos: Location): any;
    parseFragment(context: Context, children: ESTree.JSXElement[], openingElement: ESTree.JSXOpeningElement, closingElement: ESTree.JSXClosingElement, pos: Location): any;
}
